# 6장 프록시

- 클라이언트와 서버 중간에서 요청을 중개해주는 역할
- 개인 프록시와 공용 프록시로 나뉘며 대부분의 프록시는 공용 프록시

## 프록시 vs 게이트웨이

- 프록시는 같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결
- 게이트웨이는 서로 다른 프로토콜을 사용하는 둘 이상을 연결

## 프록시를 사용하는 이유

- 문서 접근 제어
  - 웹서버의 리소스들에 대한 단일 접근 제한 기능
- 보안 방화벽
  - 인바운드, 아웃바운드 흐름을 감시하고 통제
- 캐시
  - 인기있는 문서의 사본을 관리하고 요청 시 빠르게 제공
- 대리 프록시(Surrogate) 혹은 리버스 프록시
  - 로드밸런싱

## 프록시 서버 배치

- 출구 프록시
  - 로컬네트워크와 서버의 출구에 배치
- 접근(입구) 프록시
  - ISP 접근 지점에 두고 비용 감소 및 속도 개선을 위헤 캐시 프록시 사용
- 대리 프록시
  - 웹서버,WAS 앞에 위치해서 서버로 향하는 모든 요청을 필터 및 분산 처리
- 네트워크 교환 프록시
  - 네트워크 혼잡을 완화하고 흐름을 감시하기 위에 네트워크 사이에 인터넷 피어링 지점들에 위치

### 프록시 계층

- 프록시는 계층구조로 연쇄적으로 구성할 수 있으며 메시지는 프록시와 프록시를 거쳐 원 서버로 도착한다
- 프록시 서버들은 부모/자식 관계를 갖는데, 다음번 인바운드 프록시(서버에 가까운 쪽)을 부모라고 부르고 다음번 아웃바운드 프록시(클라이언트에 가까운 쪽)을 자식이라고 부른다.

## 프록시 계층 콘텐츠 라우팅

프록시는 일반적으로 정적이지만 동적으로 상황에 맞게 요청을 보낼 수도 있다.
동적 부모 선택의 몇 가지 예

- 부하 균형
- 지리적 인접성
- 프로토콜/타입 라우팅
- 유료서비스 가입자를 위한 라우팅

## 프록시 URI는 서버 URI와 다르다.

초기 HTTP 설계는 클라이언트는 단일 서버를 대상으로 설계 되었기 때문에 스킴과 호스트가 불필요 했음.

클라이언트가 프록시를 사용하지 않도록 설정되어 있다면 부분 URI를 보내고

프록시를 사용한다면 완전한 URI를 보낸다.

- 클라이언트가 직접 서버로 요청을 보낼 때
  - GET /index.html HTTP/1.0
- 클라이언트가 프록시로 요청을 보낼 때
  - GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.0

## 메시지 추적

### Via 헤더

- Via 헤더 필드는 메시지가 지나는 각 중간 노드의 정보를 나열한다
- 메시지가 또 다른 노드를 지날 때마다, 중간 노드는 Via 목록의 끝에 반드시 추가되어야 한다.
- Via 헤더는 프로토콜 이름, 버전, 노드 이름, 노드 코멘트로 구성된다.
  - HTTP 프로토콜은 이름 생략 가능
- 요청 메시지와 응답 메시지 모두 Via 헤더를 가진다.

```
  다음의 Via 헤더는 메시지가 두 개의 프록시를 지나갔음을 말해준다.

  Via: 1.1 proxy-62.irenes-isp.net, 1.0 cache.joes-hardware.com
```

### TRACE 메서드

- HTTP TRACE 메서드는 프록시의 연쇄를 따라가면서 메시지가 지나간 경로를 추적한다.
- 서버는 전체 요청 메시지를 응답 바디에 담아서 돌려준다.

## 프록시 상호운용성

- OPTIOS 메서드르 사용해 서버가 지원하는 메서드를 알아낼 수 있다.
